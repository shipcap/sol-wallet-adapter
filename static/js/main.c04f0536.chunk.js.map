{"version":3,"sources":["../../../src/index.ts","App.tsx","index.tsx"],"names":["e","a","toHex","buffer","Array","prototype","map","call","x","toString","slice","join","App","useState","logs","setLogs","addLog","log","network","clusterApiUrl","providerUrl","setProviderUrl","connection","useMemo","Connection","urlWallet","Wallet","injectedWallet","window","solana","console","undefined","selectedWallet","setSelectedWallet","setConnected","pubkey","publicKey","Error","transaction","Transaction","add","SystemProgram","transfer","fromPubkey","toPubkey","lamports","getRecentBlockhash","recentBlockhash","blockhash","feePayer","signTransaction","signed","sendRawTransaction","serialize","signature","confirmTransaction","warn","message","data","TextEncoder","encode","sign","useEffect","on","toBase58","connect","disconnect","className","type","value","onChange","target","trim","connected","onClick","i","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.c04f0536.chunk.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport EventEmitter from 'eventemitter3';\nimport { PublicKey } from '@solana/web3.js';\nimport bs58 from 'bs58';\nexport default class Wallet extends EventEmitter {\n    constructor(provider, _network) {\n        super();\n        this._network = _network;\n        this._publicKey = null;\n        this._popup = null;\n        this._handlerAdded = false;\n        this._nextRequestId = 1;\n        this._autoApprove = false;\n        this._responsePromises = new Map();\n        this.handleMessage = (e) => {\n            var _a;\n            if ((this._injectedProvider && e.source === window) ||\n                (e.origin === ((_a = this._providerUrl) === null || _a === void 0 ? void 0 : _a.origin) && e.source === this._popup)) {\n                if (e.data.method === 'connected') {\n                    const newPublicKey = new PublicKey(e.data.params.publicKey);\n                    if (!this._publicKey || !this._publicKey.equals(newPublicKey)) {\n                        if (this._publicKey && !this._publicKey.equals(newPublicKey)) {\n                            this.handleDisconnect();\n                        }\n                        this._publicKey = newPublicKey;\n                        this._autoApprove = !!e.data.params.autoApprove;\n                        this.emit('connect', this._publicKey);\n                    }\n                }\n                else if (e.data.method === 'disconnected') {\n                    this.handleDisconnect();\n                }\n                else if (e.data.result || e.data.error) {\n                    const promises = this._responsePromises.get(e.data.id);\n                    if (promises) {\n                        const [resolve, reject] = promises;\n                        if (e.data.result) {\n                            resolve(e.data.result);\n                        }\n                        else {\n                            reject(new Error(e.data.error));\n                        }\n                    }\n                }\n            }\n        };\n        this._beforeUnload = () => {\n            void this.disconnect();\n        };\n        if (isInjectedProvider(provider)) {\n            this._injectedProvider = provider;\n        }\n        else if (isString(provider)) {\n            this._providerUrl = new URL(provider);\n            this._providerUrl.hash = new URLSearchParams({\n                origin: window.location.origin,\n                network: this._network,\n            }).toString();\n        }\n        else {\n            throw new Error('provider parameter must be an injected provider or a URL string.');\n        }\n    }\n    handleConnect() {\n        var _a;\n        if (!this._handlerAdded) {\n            this._handlerAdded = true;\n            window.addEventListener('message', this.handleMessage);\n            window.addEventListener('beforeunload', this._beforeUnload);\n        }\n        if (this._injectedProvider) {\n            return new Promise((resolve) => {\n                void this.sendRequest('connect', {});\n                resolve();\n            });\n        }\n        else {\n            window.name = 'parent';\n            this._popup = window.open((_a = this._providerUrl) === null || _a === void 0 ? void 0 : _a.toString(), '_blank', 'location,resizable,width=460,height=675');\n            return new Promise((resolve) => {\n                this.once('connect', resolve);\n            });\n        }\n    }\n    handleDisconnect() {\n        if (this._handlerAdded) {\n            this._handlerAdded = false;\n            window.removeEventListener('message', this.handleMessage);\n            window.removeEventListener('beforeunload', this._beforeUnload);\n        }\n        if (this._publicKey) {\n            this._publicKey = null;\n            this.emit('disconnect');\n        }\n        this._responsePromises.forEach(([, reject], id) => {\n            this._responsePromises.delete(id);\n            reject(new Error('Wallet disconnected'));\n        });\n    }\n    sendRequest(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (method !== 'connect' && !this.connected) {\n                throw new Error('Wallet not connected');\n            }\n            const requestId = this._nextRequestId;\n            ++this._nextRequestId;\n            return new Promise((resolve, reject) => {\n                var _a, _b, _c, _d;\n                this._responsePromises.set(requestId, [resolve, reject]);\n                if (this._injectedProvider) {\n                    this._injectedProvider.postMessage({\n                        jsonrpc: '2.0',\n                        id: requestId,\n                        method,\n                        params: Object.assign({ network: this._network }, params),\n                    });\n                }\n                else {\n                    (_a = this._popup) === null || _a === void 0 ? void 0 : _a.postMessage({\n                        jsonrpc: '2.0',\n                        id: requestId,\n                        method,\n                        params,\n                    }, (_c = (_b = this._providerUrl) === null || _b === void 0 ? void 0 : _b.origin) !== null && _c !== void 0 ? _c : '');\n                    if (!this.autoApprove) {\n                        (_d = this._popup) === null || _d === void 0 ? void 0 : _d.focus();\n                    }\n                }\n            });\n        });\n    }\n    get publicKey() {\n        return this._publicKey;\n    }\n    get connected() {\n        return this._publicKey !== null;\n    }\n    get autoApprove() {\n        return this._autoApprove;\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._popup) {\n                this._popup.close();\n            }\n            yield this.handleConnect();\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._injectedProvider) {\n                yield this.sendRequest('disconnect', {});\n            }\n            if (this._popup) {\n                this._popup.close();\n            }\n            this.handleDisconnect();\n        });\n    }\n    sign(data, display) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(data instanceof Uint8Array)) {\n                throw new Error('Data must be an instance of Uint8Array');\n            }\n            const response = (yield this.sendRequest('sign', {\n                data,\n                display,\n            }));\n            const signature = bs58.decode(response.signature);\n            const publicKey = new PublicKey(response.publicKey);\n            return {\n                signature,\n                publicKey,\n            };\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = (yield this.sendRequest('signTransaction', {\n                message: bs58.encode(transaction.serializeMessage()),\n            }));\n            const signature = bs58.decode(response.signature);\n            const publicKey = new PublicKey(response.publicKey);\n            transaction.addSignature(publicKey, signature);\n            return transaction;\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = (yield this.sendRequest('signAllTransactions', {\n                messages: transactions.map((tx) => bs58.encode(tx.serializeMessage())),\n            }));\n            const signatures = response.signatures.map((s) => bs58.decode(s));\n            const publicKey = new PublicKey(response.publicKey);\n            transactions = transactions.map((tx, idx) => {\n                tx.addSignature(publicKey, signatures[idx]);\n                return tx;\n            });\n            return transactions;\n        });\n    }\n}\nfunction isString(a) {\n    return typeof a === 'string';\n}\nfunction isInjectedProvider(a) {\n    return (isObject(a) && 'postMessage' in a && typeof a.postMessage === 'function');\n}\nfunction isObject(a) {\n    return typeof a === 'object' && a !== null;\n}\n//# sourceMappingURL=index.js.map","import React, { useEffect, useMemo, useState } from 'react';\nimport './App.css';\nimport Wallet from '@project-serum/sol-wallet-adapter';\nimport {\n  Connection,\n  SystemProgram,\n  Transaction,\n  clusterApiUrl,\n} from '@solana/web3.js';\n\nfunction toHex(buffer: Buffer) {\n  return Array.prototype.map\n    .call(buffer, (x: number) => ('00' + x.toString(16)).slice(-2))\n    .join('');\n}\n\nfunction App(): React.ReactElement {\n  const [logs, setLogs] = useState<string[]>([]);\n  function addLog(log: string) {\n    setLogs((logs) => [...logs, log]);\n  }\n\n  const network = clusterApiUrl('devnet');\n  const [providerUrl, setProviderUrl] = useState('https://www.sollet.io');\n  const connection = useMemo(() => new Connection(network), [network]);\n  const urlWallet = useMemo(\n    () => new Wallet(providerUrl, network),\n    [providerUrl, network],\n  );\n  const injectedWallet = useMemo(() => {\n    try {\n      return new Wallet(\n        (window as unknown as { solana: unknown }).solana,\n        network,\n      );\n    } catch (e) {\n      console.log(`Could not create injected wallet`, e);\n      return null;\n    }\n  }, [network]);\n  const [selectedWallet, setSelectedWallet] = useState<\n    Wallet | undefined | null\n  >(undefined);\n  const [, setConnected] = useState(false);\n  useEffect(() => {\n    if (selectedWallet) {\n      selectedWallet.on('connect', () => {\n        setConnected(true);\n        addLog(\n          `Connected to wallet ${selectedWallet.publicKey?.toBase58() ?? '--'}`,\n        );\n      });\n      selectedWallet.on('disconnect', () => {\n        setConnected(false);\n        addLog('Disconnected from wallet');\n      });\n      void selectedWallet.connect();\n      return () => {\n        void selectedWallet.disconnect();\n      };\n    }\n  }, [selectedWallet]);\n\n  async function sendTransaction() {\n    try {\n      const pubkey = selectedWallet?.publicKey;\n      if (!pubkey || !selectedWallet) {\n        throw new Error('wallet not connected');\n      }\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: pubkey,\n          toPubkey: pubkey,\n          lamports: 100,\n        }),\n      );\n      addLog('Getting recent blockhash');\n      transaction.recentBlockhash = (\n        await connection.getRecentBlockhash()\n      ).blockhash;\n      addLog('Sending signature request to wallet');\n      transaction.feePayer = pubkey;\n      const signed = await selectedWallet.signTransaction(transaction);\n      addLog('Got signature, submitting transaction');\n      const signature = await connection.sendRawTransaction(signed.serialize());\n      addLog('Submitted transaction ' + signature + ', awaiting confirmation');\n      await connection.confirmTransaction(signature, 'singleGossip');\n      addLog('Transaction ' + signature + ' confirmed');\n    } catch (e) {\n      console.warn(e);\n      addLog(`Error: ${(e as Error).message}`);\n    }\n  }\n\n  async function signMessage() {\n    try {\n      if (!selectedWallet) {\n        throw new Error('wallet not connected');\n      }\n      const message =\n        'Please sign this message for proof of address ownership.';\n      addLog('Sending message signature request to wallet');\n      const data = new TextEncoder().encode(message);\n      const signed = await selectedWallet.sign(data, 'hex');\n      addLog('Got signature: ' + toHex(signed.signature));\n    } catch (e) {\n      console.warn(e);\n      addLog(`Error: ${(e as Error).message}`);\n    }\n  }\n\n  return (\n    <div className=\"App\">\n      <h1>Wallet Adapter Demo</h1>\n      <div>Network: {network}</div>\n      <div>\n        Waller provider:{' '}\n        <input\n          type=\"text\"\n          value={providerUrl}\n          onChange={(e) => setProviderUrl(e.target.value.trim())}\n        />\n      </div>\n      {selectedWallet && selectedWallet.connected ? (\n        <div>\n          <div>Wallet address: {selectedWallet.publicKey?.toBase58()}.</div>\n          <button onClick={sendTransaction}>Send Transaction</button>\n          <button onClick={signMessage}>Sign Message</button>\n          <button onClick={() => selectedWallet.disconnect()}>\n            Disconnect\n          </button>\n        </div>\n      ) : (\n        <div>\n          <button onClick={() => setSelectedWallet(urlWallet)}>\n            Connect to Wallet\n          </button>\n          <button onClick={() => setSelectedWallet(injectedWallet)}>\n            Connect to Injected Wallet\n          </button>\n        </div>\n      )}\n      <hr />\n      <div className=\"logs\">\n        {logs.map((log, i) => (\n          <div key={i}>{log}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import './index.css';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}